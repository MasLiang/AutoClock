import device_resource
import pulp
from mmcm_fac_calc import mmcm_multi_calc_fac
from pll_fac_calc import pll_calc_fac

def bufgce_div_cal(domains):
    # This function is to find those clocks that can be 
    # generated by another clock with bufgce_div. If a clock can be generated 
    # by another clock, it will be removed from domains and added to a map.

    # return the map and new domains.

    # In domains passed into this function, the first one 
    # is source clock, that is to say, it can never be generated 
    # by other clocks and other clocks must be generated by it in the end. 
    
    print("***** bugce_div***** ")
    print(domains)
    cp_domains = domains.copy()
    lst_domains = list(domains.keys())
    src_clk = lst_domains[0]

    # rebuild the domains map, using frequency as the key
    domains_rebuild = {}
    for domain in lst_domains:
        domains_rebuild[str(domains[domain])] = domain
    
    # a dict, key: [type, src, div_fac]
    clk_map = {}
    
    ## check if there is any clock domains that can be generated by bufgce_div
    ## from source clock
    #for domain in lst_domains[1:]:
    #    if (domains[domain]%domains[src_clk]==0) and (domains[domain]//domains[src_clk]<9) and (domains[domain]//domains[src_clk]>0):
    #        have_child_clk = True
    #        clk_map[domain] = ["bufgce_div",src_clk,domains[domain]//domains[src_clk]]
    #        del domains[domain]
    #
    ## if all clocks have been solved, return
    #if ((len(domains) <=1) or (not have_child_clk)):
    #    return clk_map, domains

    ## check if there is any clock domains that can be generated by bufgce_div
    ## from other clocks rather than source clock
    #del domains[src_clk]
    #clk_map_child, domains = bufgce_div_cal(domains)
    #clk_map.update(clk_map_child)
    #for new_src_clk in list(clk_map.keys()):
    #    clk_map_child, domains = bufgce_div_cal({new_src_clk:cp_domains[new_src_clk], **domains})
    #    clk_map.update(clk_map_child)
    #    del domains[new_src_clk]
    #
    #domains = {src_clk:src_clk_val, **domains}
    
    # sort from low frequency to higher frequency
    lst_domains_rebuild = list(domains_rebuild.keys())
    lst_domains_rebuild.sort(key=lambda e:float(e))
    num_domains = len(lst_domains_rebuild)
    for src_domain_idx in range(num_domains-1):
        for target_domain_idx in range(src_domain_idx+1, num_domains):
            src_domain = lst_domains_rebuild[src_domain_idx]
            target_domain = lst_domains_rebuild[target_domain_idx]
            if domains_rebuild[target_domain]==src_clk:
                continue
            if (float(target_domain)%float(src_domain)==0) and (float(target_domain)//float(src_domain)<9) and (float(target_domain)//float(src_domain)>0):
                clk_map[domains_rebuild[target_domain]] = ["bufgce_div",domains_rebuild[src_domain],float(target_domain)//float(src_domain)]
                del domains[domains_rebuild[target_domain]]
    
    return clk_map, domains

def bufgce_mux_cal(domains, u50_flg):
    # This function is to deal with clk mux. If there is a clock domain have more 
    #  than one period, this clock will be muxed from other temp clocks.
    
    # **** default u50_flg == 1'b1, meanning that all clock must have 50% duty cycle
    # **** u50_flg == 1'b0 ****
    # ** If clock with duty cycle not being 50% is accepted, do this analyze **
    # Analyze if some of these period can be generated by others according to BUFG.
    # For example, if a clock has three choices: 10ns, 20ns, 30ns. If fact BUFGCE_MUX 
    # is not needed. Only a BUFG with an changed enable is needed with a 10ns clock.
    # But, this will lead to duty cycle not being 50%. 
    # The advantage is that, BUFGCE_MUX need to share BUFGCTRL with many other BUF while
    # there are some independent BUFGCE in FPGA.
    

    # Then add temp clocks into domains, remove the original clock for domains.
    # Return new domains and a clock_mux_map.
    
    clk_map = {}
    for domain in list(domains.keys()):
        periods = domains[domain].split()
        num_periods = len(periods)
        if(num_periods>1):
            if(u50_flg):
                sel_clk = []
                for i in range(num_periods):
                    sel_clk.append(domain+"_"+str(i))
                    domains = {**domains, domain+"_"+str(i):periods[i]}
                del domains[domain]
                clk_map[domain] = ["bufgce_mux", sel_clk]
            else:
                return # TODO
                                

    # for calculation later, strings are converted to float
    for domain in list(domains.keys()):
        domains[domain] = float(domains[domain])
    
    # Since there are only 2 input pins of a MUX, mux with more than
    #  2 input should be divided.
    for mux in list(clk_map.keys()):
        mux_clk = clk_map[mux][1]
        while(len(mux_clk)>1):
            mux_clk1 = mux_clk.pop()
            mux_clk2 = mux_clk.pop()
            mux_out = mux_clk2+"_temp"
            mux_clk.append(mux_out)
            clk_map[mux_out] = ["bufgce_mux", [mux_clk1, mux_clk2]] 
        clk_map[mux] = clk_map[mux_out]
        del clk_map[mux_out]
        
    return clk_map, domains
                
def bypass_cal(domains):
    # This function is to find clocks with the same period.
    
    clk_map = {}

    lst_domains = list(domains.keys())
    src_clk = lst_domains[0]
    src_clk_val = domains[src_clk]

    for domain in lst_domains[1:]:
        if(domains[domain]==domains[src_clk]):
            clk_map[domain] = ["bypass", src_clk]
            del domains[domain]
    del domains[src_clk]
    
    if(len(domains)==0):
        domains = {src_clk:src_clk_val, **domains}
        return clk_map, domains

    clk_map_child, domains = bypass_cal(domains)
    clk_map.update(clk_map_child)
    domains = {src_clk:src_clk_val, **domains}
    
    return clk_map, domains
   
def pll_mmcm_cal(domains):
    device_info = [100, 100, 0.049, 0.097, 2, 7]
    # this function is to calculate the number of PLL and MMCM needed
    # A PLL can generate 2 clock domains and A MMCM can generate 7 clock domains
    # PLL cost 0.049W and 1 MMCM cost 0.097 W.
    # To get the optimal solution, a ILP solver is used based on the following equation:
    # min(n_{PLL}\times p_{PLL}+n_{MMCM}\times p_{MMCM})
    # s.t. n_{PLL}<=N_{PLL}
    # s.t. n_{MMCM}<=N_{MMCM}
    # s.t. 2\times n_{PLL}+7\times n_{MMCM}>=n_{freq}
    # s.t. n_{PLL}\in \mathbb{Z}
    # s.t. n_{MMCM}\in \mathbb{Z}
    
    # device_info = [pll_number, mmcm_number, pll_power, mmcm_power, num_clock_per_pll, num_clock_per_mmcm]

    print("*****")
    print( domains)
    ilp_solver = pulp.LpProblem("pll_mmcm_ilp", sense=pulp.LpMinimize)
    n_pll = pulp.LpVariable('n_pll', lowBound=0, upBound=device_info[0], cat=pulp.LpInteger)
    n_mmcm = pulp.LpVariable('n_mmcm', lowBound=0, upBound=device_info[1], cat=pulp.LpInteger)
    ilp_solver += n_pll*device_info[2] + n_mmcm*device_info[3]
    ilp_solver += n_pll*device_info[4] + n_mmcm*device_info[5] >= len(list(domains.keys()))
    ilp_solver.solve()
    print("Status:", pulp.LpStatus[ilp_solver.status]) 
    for v in ilp_solver.variables():
        print(v.name, "=", v.varValue)  
    print("F(x) = ", pulp.value(ilp_solver.objective))  

    mmcm_map = mmcm_multi_calc_fac(domains)
    src_clk = list(mmcm_map.keys())[0]
    num_mmcm_unit = len(mmcm_map[src_clk])
    for mmcm_idx in range(num_mmcm_unit):
        mmcm_caled_domain_lst = mmcm_map[src_clk][mmcm_idx][1]
        if len(mmcm_caled_domain_lst)<3:
            pll_recal_period_list = []
            for domain in mmcm_caled_domain_lst:
                pll_recal_period_list.append(domains[domain])
            pll_fac = pll_calc_fac(domains[src_clk], pll_recal_period_list, len(mmcm_caled_domain_lst))
            if(pll_fac!=[]):
                mmcm_map[src_clk][mmcm_idx][0] = "pll"
                mmcm_map[src_clk][mmcm_idx][2] = pll_fac

    return mmcm_map

def clk_resource_cal(domains):
    # clk_map is used to generate some BUFs
    # domains is used to generate PLL
    clk_map_mux, domains =  bufgce_mux_cal(domains, 1)
    clk_map_bypass, domains = bypass_cal(domains)
    clk_map_div, domains =  bufgce_div_cal(domains)
    clk_map_mmcm = pll_mmcm_cal(domains)

    return clk_map_mux, clk_map_bypass, clk_map_div, clk_map_mmcm

