#import device_resource
import pulp
import itertools
from .mmcm_fac_calc import *
from .pll_fac_calc import *

def bufgce_div_cal(domains):
    # This function is to find those clocks that can be 
    # generated by another clock with bufgce_div. If a clock can be generated 
    # by another clock, it will be removed from domains and added to a map.

    # return the map and new domains.

    # In domains passed into this function, the first one 
    # is source clock, that is to say, it can never be generated 
    # by other clocks and other clocks must be generated by it in the end. 
    
    cp_domains = domains.copy()
    lst_domains = list(domains.keys())
    src_clk = lst_domains[0]

    # rebuild the domains map, using frequency as the key
    domains_rebuild = {}
    for domain in lst_domains:
        domains_rebuild[str(domains[domain])] = domain
    
    # a dict, key: [type, src, div_fac]
    clk_map = {}
    
    # sort from low frequency to higher frequency
    lst_domains_rebuild = list(domains_rebuild.keys())
    lst_domains_rebuild.sort(key=lambda e:float(e))
    num_domains = len(lst_domains_rebuild)
    for src_domain_idx in range(num_domains-1):
        for target_domain_idx in range(src_domain_idx+1, num_domains):
            new_lst_domains = list(domains.keys())
            if not domains_rebuild[lst_domains_rebuild[target_domain_idx]] in new_lst_domains:
                continue
            src_domain = lst_domains_rebuild[src_domain_idx]
            target_domain = lst_domains_rebuild[target_domain_idx]
            if domains_rebuild[target_domain]==src_clk:
                continue
            if (float(target_domain)%float(src_domain)==0) and (float(target_domain)//float(src_domain)<9) and (float(target_domain)//float(src_domain)>0):
                clk_map[domains_rebuild[target_domain]] = ["bufgce_div",domains_rebuild[src_domain],float(target_domain)//float(src_domain)]
                del domains[domains_rebuild[target_domain]]
    
    return clk_map, domains

def bufgce_mux_cal(domains, modules, domains_sel_if, u50_flg):
    # This function is to deal with clk mux. If there is a clock domain have more 
    #  than one period, this clock will be muxed from other temp clocks.
    
    # **** default u50_flg == 1'b1, meanning that all clock must have 50% duty cycle
    # **** u50_flg == 1'b0 ****
    # ** If clock with duty cycle not being 50% is accepted, do this analyze **
    # Analyze if some of these period can be generated by others according to BUFG.
    # For example, if a clock has three choices: 10ns, 20ns, 30ns. If fact BUFGCE_MUX 
    # is not needed. Only a BUFG with an changed enable is needed with a 10ns clock.
    # But, this will lead to duty cycle not being 50%. 
    # The advantage is that, BUFGCE_MUX need to share BUFGCTRL with many other BUF while
    # there are some independent BUFGCE in FPGA.
    

    # Then add temp clocks into domains, remove the original clock for domains.
    # Return new domains and a clock_mux_map.
    
    clk_map = {}
    # After this function, output of mux will be removed from domains.
    # However, they will be connected to output. So, record them.
    mux_out_domain = {}
    # User configure clock mux
    for domain in list(domains.keys()):
        periods = domains[domain].split()
        num_periods = len(periods)
        if(num_periods>1):
            if(u50_flg):
                sel_clk = []
                for i in range(num_periods):
                    sel_clk.append(domain+"_"+str(i))
                    domains = {**domains, domain+"_"+str(i):periods[i]}
                del domains[domain]
                clk_map[domain] = ["bufgce_mux", sel_clk]
            else:
                return # TODO
    # infered clock mux for TDM modules. After verilog code being generated, 
    #   this part will be further checked. If VITIS do not TDM them, this 
    #   part will not be used. 
    # TODO: how to map from module to verilog? change name?
    for module in list(modules.keys()):
        domains_of_module = modules[module]
        num_domains = len(domains_of_module)
        if len(domains_of_module)>1:
            sel_clk = []
            for i in domains_of_module:
                sel_clk.append(i)
            # new domain name module+"_clk"
            clk_map[module+"_clk"] = ["bufgce_mux", sel_clk]
            mux_out_domain[module] = module+"_clk"
            domains_sel_if[module+"_clk"] = ["sel"]

    # for calculation later, strings are converted to float
    for domain in list(domains.keys()):
        domains[domain] = float(domains[domain])
    
    # Since there are only 2 input pins of a MUX, mux with more than
    #  2 input should be divided.
    for mux in list(clk_map.keys()):
        mux_clk = clk_map[mux][1]
        while(len(mux_clk)>1):
            mux_clk1 = mux_clk.pop()
            mux_clk2 = mux_clk.pop()
            mux_out = mux_clk2+"_temp"
            mux_clk.append(mux_out)
            clk_map[mux_out] = ["bufgce_mux", [mux_clk1, mux_clk2]] 
        clk_map[mux] = clk_map[mux_out]
        del clk_map[mux_out]
        
    return clk_map, domains, mux_out_domain
                
def bypass_cal(domains):
    # This function is to find clocks with the same period.
    
    clk_map = {}

    lst_domains = list(domains.keys())
    src_clk = lst_domains[0]
    src_clk_val = domains[src_clk]

    for domain in lst_domains[1:]:
        if(domains[domain]==domains[src_clk]):
            clk_map[domain] = ["bypass", src_clk]
            del domains[domain]
    del domains[src_clk]
    
    if(len(domains)==0):
        domains = {src_clk:src_clk_val, **domains}
        return clk_map, domains

    clk_map_child, domains = bypass_cal(domains)
    clk_map.update(clk_map_child)
    domains = {src_clk:src_clk_val, **domains}
    
    return clk_map, domains
   
def pll_mmcm_cal(domains):
    # this function is to calculate the number of PLL and MMCM needed
    # A PLL can generate 2 clock domains and A MMCM can generate 7 clock domains
    # PLL cost 0.049W and 1 MMCM cost 0.099 W.
    # To get the optimal solution, a ILP solver is used based on the following equation:
    # min(n_{PLL}\times p_{PLL}+n_{MMCM}\times p_{MMCM})
    # s.t. n_{PLL}<=N_{PLL}
    # s.t. n_{MMCM}<=N_{MMCM}
    # s.t. 2\times n_{PLL}+7\times n_{MMCM}>=n_{freq}
    # s.t. n_{PLL}\in \mathbb{Z}
    # s.t. n_{MMCM}\in \mathbb{Z}
    
    # device_info = [pll_number, mmcm_number, pll_power, mmcm_power, num_clock_per_pll, num_clock_per_mmcm]
    device_info = [100, 100, 0.049, 0.099, 2, 7]

    ilp_solver = pulp.LpProblem("pll_mmcm_ilp", sense=pulp.LpMinimize)
    n_pll = pulp.LpVariable('n_pll', lowBound=0, upBound=device_info[0], cat=pulp.LpInteger)
    n_mmcm = pulp.LpVariable('n_mmcm', lowBound=0, upBound=device_info[1], cat=pulp.LpInteger)
    ilp_solver += n_pll*device_info[2] + n_mmcm*device_info[3]
    ilp_solver += n_pll*device_info[4] + n_mmcm*device_info[5] >= len(list(domains.keys()))
    # iteration
    while 1:
        # get a solution
        ilp_solver.solve()
        for v in ilp_solver.variables():
            if v.name=="n_pll":
                num_pll = int(v.varValue)
            elif v.name=="n_mmcm":
                num_mmcm = int(v.varValue)
        # power of current solution
        p_min = num_pll*device_info[2]+n_mmcm*device_info[3]

        lst_domains = list(domains.keys())
        if num_mmcm==0:
            mmcm_map = pll_multi_calc_fac(domains, num_pll)
            if mmcm_map=={}:
                # add new constraint
                ilp_solver += n_pll*device_info[2] + n_mmcm*device_info[3] > p_min
                continue
            else:
                return mmcm_map
        elif num_pll==0:
            mmcm_map = mmcm_multi_calc_fac(domains, num_mmcm)
            if mmcm_map=={}:
                # add new constraint
                ilp_solver += n_pll*device_info[2] + n_mmcm*device_info[3] > p_min
                continue
            else:
                return mmcm_map
        else:
            # TODO: need to validate all combinations
            #all_combinations = list(itertools.permutations(my_list))
            for comb in itertools.permutations(lst_domains):
                lst_domains_pll = comb[1:2*num_pll+1]
                lst_domains_mmcm = comb[2*num_pll+1:]
                domains_pll = {}
                domains_mmcm = {}
                domains_pll[lst_domains[0]] = domains[lst_domains[0]]
                domains_mmcm[lst_domains[0]] = domains[lst_domains[0]]
                for domain in lst_domains_pll:
                    domains_pll[domain] = domains[domain]
                for domain in lst_domains_mmcm:
                    domains_mmcm[domain] = domains[domain]
                pll_map = pll_multi_calc_fac(domains_pll)
                mmcm_map = mmcm_multi_calc_fac(domains_mmcm)
                if pll_map=={} or mmcm_map=={}:
                    continue
                mmcm_map[lst_domains[0]] += pll_map[lst_domains[0]]
                return mmcm_map
            ilp_solver += n_pll*device_info[2] + n_mmcm*device_info[3] > p_min
            continue

def clk_resource_cal(domains, modules, domains_sel_if):
    # clk_map is used to generate some BUFs
    # domains is used to generate PLL
    domains_copy = domains.copy()
    modules_copy = modules.copy()
    clk_map_mux, domains_copy, mux_out_domain =  bufgce_mux_cal(domains_copy, modules_copy, domains_sel_if, 1)
    clk_map_bypass, domains_copy = bypass_cal(domains_copy)
    clk_map_div, domains_copy =  bufgce_div_cal(domains_copy)
    clk_map_mmcm = pll_mmcm_cal(domains_copy)

    return clk_map_mux, clk_map_bypass, clk_map_div, clk_map_mmcm, mux_out_domain

