import device_resource
import pulp
from mmcm_fac_calc import *
from pll_fac_calc import *

def bufgce_div_cal(domains):
    # This function is to find those clocks that can be 
    # generated by another clock with bufgce_div. If a clock can be generated 
    # by another clock, it will be removed from domains and added to a map.

    # return the map and new domains.

    # In domains passed into this function, the first one 
    # is source clock, that is to say, it can never be generated 
    # by other clocks and other clocks must be generated by it in the end. 
    
    print("***** bugce_div***** ")
    print(domains)
    cp_domains = domains.copy()
    lst_domains = list(domains.keys())
    src_clk = lst_domains[0]

    # rebuild the domains map, using frequency as the key
    domains_rebuild = {}
    for domain in lst_domains:
        domains_rebuild[str(domains[domain])] = domain
    
    # a dict, key: [type, src, div_fac]
    clk_map = {}
    
    # sort from low frequency to higher frequency
    lst_domains_rebuild = list(domains_rebuild.keys())
    lst_domains_rebuild.sort(key=lambda e:float(e))
    num_domains = len(lst_domains_rebuild)
    for src_domain_idx in range(num_domains-1):
        for target_domain_idx in range(src_domain_idx+1, num_domains):
            new_lst_domains = list(domains.keys())
            if not domains_rebuild[lst_domains_rebuild[target_domain_idx]] in new_lst_domains:
                continue
            src_domain = lst_domains_rebuild[src_domain_idx]
            target_domain = lst_domains_rebuild[target_domain_idx]
            if domains_rebuild[target_domain]==src_clk:
                continue
            if (float(target_domain)%float(src_domain)==0) and (float(target_domain)//float(src_domain)<9) and (float(target_domain)//float(src_domain)>0):
                clk_map[domains_rebuild[target_domain]] = ["bufgce_div",domains_rebuild[src_domain],float(target_domain)//float(src_domain)]
                print(domains)
                print(target_domain)
                print(domains_rebuild[target_domain])
                del domains[domains_rebuild[target_domain]]
    
    return clk_map, domains

def bufgce_mux_cal(domains, u50_flg):
    # This function is to deal with clk mux. If there is a clock domain have more 
    #  than one period, this clock will be muxed from other temp clocks.
    
    # **** default u50_flg == 1'b1, meanning that all clock must have 50% duty cycle
    # **** u50_flg == 1'b0 ****
    # ** If clock with duty cycle not being 50% is accepted, do this analyze **
    # Analyze if some of these period can be generated by others according to BUFG.
    # For example, if a clock has three choices: 10ns, 20ns, 30ns. If fact BUFGCE_MUX 
    # is not needed. Only a BUFG with an changed enable is needed with a 10ns clock.
    # But, this will lead to duty cycle not being 50%. 
    # The advantage is that, BUFGCE_MUX need to share BUFGCTRL with many other BUF while
    # there are some independent BUFGCE in FPGA.
    

    # Then add temp clocks into domains, remove the original clock for domains.
    # Return new domains and a clock_mux_map.
    
    clk_map = {}
    for domain in list(domains.keys()):
        periods = domains[domain].split()
        num_periods = len(periods)
        if(num_periods>1):
            if(u50_flg):
                sel_clk = []
                for i in range(num_periods):
                    sel_clk.append(domain+"_"+str(i))
                    domains = {**domains, domain+"_"+str(i):periods[i]}
                del domains[domain]
                clk_map[domain] = ["bufgce_mux", sel_clk]
            else:
                return # TODO
                                

    # for calculation later, strings are converted to float
    for domain in list(domains.keys()):
        domains[domain] = float(domains[domain])
    
    # Since there are only 2 input pins of a MUX, mux with more than
    #  2 input should be divided.
    for mux in list(clk_map.keys()):
        mux_clk = clk_map[mux][1]
        while(len(mux_clk)>1):
            mux_clk1 = mux_clk.pop()
            mux_clk2 = mux_clk.pop()
            mux_out = mux_clk2+"_temp"
            mux_clk.append(mux_out)
            clk_map[mux_out] = ["bufgce_mux", [mux_clk1, mux_clk2]] 
        clk_map[mux] = clk_map[mux_out]
        del clk_map[mux_out]
        
    return clk_map, domains
                
def bypass_cal(domains):
    # This function is to find clocks with the same period.
    
    clk_map = {}

    lst_domains = list(domains.keys())
    src_clk = lst_domains[0]
    src_clk_val = domains[src_clk]

    for domain in lst_domains[1:]:
        if(domains[domain]==domains[src_clk]):
            clk_map[domain] = ["bypass", src_clk]
            del domains[domain]
    del domains[src_clk]
    
    if(len(domains)==0):
        domains = {src_clk:src_clk_val, **domains}
        return clk_map, domains

    clk_map_child, domains = bypass_cal(domains)
    clk_map.update(clk_map_child)
    domains = {src_clk:src_clk_val, **domains}
    
    return clk_map, domains
   
def pll_mmcm_cal(domains):
    device_info = [100, 100, 0.049, 0.099, 2, 7]
    # this function is to calculate the number of PLL and MMCM needed
    # A PLL can generate 2 clock domains and A MMCM can generate 7 clock domains
    # PLL cost 0.049W and 1 MMCM cost 0.099 W.
    # To get the optimal solution, a ILP solver is used based on the following equation:
    # min(n_{PLL}\times p_{PLL}+n_{MMCM}\times p_{MMCM})
    # s.t. n_{PLL}<=N_{PLL}
    # s.t. n_{MMCM}<=N_{MMCM}
    # s.t. 2\times n_{PLL}+7\times n_{MMCM}>=n_{freq}
    # s.t. n_{PLL}\in \mathbb{Z}
    # s.t. n_{MMCM}\in \mathbb{Z}
    # TODO: do not consider if two clocks can be generated by the same pll or mmcm
    #       currently, all clocks can be generated by the same pll or mmcm from src
    
    # device_info = [pll_number, mmcm_number, pll_power, mmcm_power, num_clock_per_pll, num_clock_per_mmcm]

    ilp_solver = pulp.LpProblem("pll_mmcm_ilp", sense=pulp.LpMinimize)
    n_pll = pulp.LpVariable('n_pll', lowBound=0, upBound=device_info[0], cat=pulp.LpInteger)
    n_mmcm = pulp.LpVariable('n_mmcm', lowBound=0, upBound=device_info[1], cat=pulp.LpInteger)
    ilp_solver += n_pll*device_info[2] + n_mmcm*device_info[3]
    ilp_solver += n_pll*device_info[4] + n_mmcm*device_info[5] >= len(list(domains.keys()))
    ilp_solver.solve()
    for v in ilp_solver.variables():
        if v.name=="n_pll":
            num_pll = int(v.varValue)
        elif v.name=="n_mmcm":
            num_mmcm = int(v.varValue)
    print("mmcm_num: ", num_mmcm, " pll_num: ", num_pll)

    lst_domains = list(domains.keys())
    if num_mmcm==0:
        mmcm_map = pll_multi_calc_fac(domains)
    elif num_pll==0:
        mmcm_map = mmcm_multi_calc_fac(domains)
    else:
        lst_domains_pll = lst_domains[1:2*num_pll+1]
        lst_domains_mmcm = lst_domains[2*num_pll+1:]
        domains_pll = {}
        domains_mmcm = {}
        domains_pll[lst_domains[0]] = domains[lst_domains[0]]
        domains_mmcm[lst_domains[0]] = domains[lst_domains[0]]
        for domain in lst_domains_pll:
            domains_pll[domain] = domains[domain]
        for domain in lst_domains_mmcm:
            domains_mmcm[domain] = domains[domain]
        pll_map = pll_multi_calc_fac(domains_pll)
        mmcm_map = mmcm_multi_calc_fac(domains_mmcm)
        mmcm_map[lst_domains[0]] += pll_map[lst_domains[0]]
    print(mmcm_map)
    return mmcm_map
        


def clk_resource_cal(domains):
    # clk_map is used to generate some BUFs
    # domains is used to generate PLL
    clk_map_mux, domains =  bufgce_mux_cal(domains, 1)
    clk_map_bypass, domains = bypass_cal(domains)
    clk_map_div, domains =  bufgce_div_cal(domains)
    clk_map_mmcm = pll_mmcm_cal(domains)

    return clk_map_mux, clk_map_bypass, clk_map_div, clk_map_mmcm

