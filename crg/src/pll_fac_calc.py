import math

def pll_calc_first_factor(in_period, out_period):
    # This list is as this format: [[div_fac_all, mult_fac_all, [div_fac_clk1]]...]
    lst_fac = []
    for div_fac_all in range(1,15+1):
        for mult_fac_all in range(1,19+1):
            for div_fac_clk in range(1,128+1):
                if((out_period * mult_fac_all / div_fac_all / div_fac_clk)==in_period):
                    lst_fac.append([div_fac_all, mult_fac_all, div_fac_clk])
    return lst_fac

def pll_calc_later_factor(in_period, out_period, lst_factor):
    # This list is made of two list
    #   1. factor for all output clk: [[div_fac_all, mult_fac_all,[div_fac_clk1, div_fac_clk2, ...]]
    selected_lst_factor = []
    for fac_grp in lst_factor:
        for div_fac_clk in range(1,128+1):
            if((out_period * fac_grp[1] / fac_grp[0] / div_fac_clk)==in_period):
                selected_lst_factor.append(fac_grp+[div_fac_clk])
                continue
    
    return selected_lst_factor

def pll_calc_fac(in_period, out_period):
    # This function is used to calculate factor of a single PLL.
    # Mux out frequency number is 2.
    # If output is [], this PLL can not be gen.
    clkout_num = len(out_period)
    lst_factor =   pll_calc_first_factor(in_period, out_period[0])
    if(len(lst_factor)==0):
        # TODO
        # assert warnning
        return []
    if(clkout_num==1):
        return lst_factor[0]

    lst_factor = pll_calc_later_factor(in_period, out_period[1], lst_factor)
    if(len(lst_factor)==0):
        # TODO
        # assert warnning
        return  []

    return lst_factor[0]

def pll_multi_calc_fac(domains, num_pll):
    # This function is used to calculate factor of all PLL

    name_domains = list(domains.keys())
    num_domains = len(name_domains) 
    pll_map = {name_domains[0]:[]}
    

    # calculate which clock can be generated in a single PLL
    push_period_lst = []
    push_name_lst = []
    pop_domain_dic = {}
    for dom_idx in range(1,num_domains):
        push_period_lst.append(domains[name_domains[dom_idx]])
        push_name_lst.append(name_domains[dom_idx])
        pll_fac = pll_calc_fac(domains[name_domains[0]], push_period_lst)
        if(pll_fac==[]):
            if(len(push_period_lst)==1):
                # TODO: there is a clock that can not be generated by pll, it needs cascade
                # assert Error
                return {}
            pop_domain_dic = {**pop_domain_dic, push_name_lst.pop():push_period_lst.pop()}
        if(len(push_name_lst)==2):
            pll_map[name_domains[0]].append(["pll", push_name_lst, pll_fac])
            push_name_lst = []
            push_period_lst = []

    if(len(push_name_lst)!=0):
        pll_map[name_domains[0]].append(["pll", push_name_lst, pll_fac])
    
    if(pop_domain_dic=={}):
        if len(pll_map[name_domains[0]])>num_pll:
            return {}
        return pll_map

    later_pll_map = pll_multi_calc_fac({name_domains[0]:domains[name_domains[0]], **pop_domain_dic}, num_pll)
    pll_map[name_domains[0]] = pll_map[name_domains[0]]+later_pll_map[name_domains[0]]
                
    if len(pll_map[name_domains[0]])>num_pll:
        return {}
    return pll_map
