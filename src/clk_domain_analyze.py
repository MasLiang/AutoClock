import device_resource
from mmcm_fac_calc import mmcm_multi_calc_fac
from pll_fac_calc import pll_calc_fac

def bufgce_div_cal(domains):
    # This function is to find those clocks that can be 
    # generated by another clock with bufgce_div. If a clock can be generated 
    # by another clock, it will be removed from domains and added to a map.

    # return the map and new domains.

    # In domains passed into this function, the first one 
    # is source clock, that is to say, it can never be generated 
    # by other clocks and other clocks must be generated by it in the end. 
    
    cp_domains = domains.copy()
    lst_domains = list(domains.keys())
    src_clk = lst_domains[0]
    src_clk_val = domains[src_clk]
    
    # a dict, key: [type, src, div_fac]
    clk_map = {}
    have_child_clk = False
    
    # check if there is any clock domains that can be generated by bufgce_div
    # from source clock
    for domain in lst_domains[1:]:
        if (domains[domain]%domains[src_clk]==0) and (domains[domain]//domains[src_clk]<9) and (domains[domain]//domains[src_clk]>0):
            have_child_clk = True
            clk_map[domain] = ["bufgce_div",src_clk,domains[domain]//domains[src_clk]]
            del domains[domain]
    
    # if all clocks have been solved, return
    if ((len(domains) <=1) or (not have_child_clk)):
        return clk_map, domains

    # check if there is any clock domains that can be generated by bufgce_div
    # from other clocks rather than source clock
    del domains[src_clk]
    clk_map_child, domains = bufgce_div_cal(domains)
    clk_map.update(clk_map_child)
    for new_src_clk in list(clk_map.keys()):
        clk_map_child, domains = bufgce_div_cal({new_src_clk:cp_domains[new_src_clk], **domains})
        clk_map.update(clk_map_child)
        del domains[new_src_clk]
    
    domains = {src_clk:src_clk_val, **domains}
    
    return clk_map, domains

def bufgce_mux_cal(domains, u50_flg):
    # This function is to deal with clk mux. If there is a clock domain have more 
    #  than one period, this clock will be muxed from other temp clocks.
    
    # **** default u50_flg == 1'b1, meanning that all clock must have 50% duty cycle
    # **** u50_flg == 1'b0 ****
    # ** If clock with duty cycle not being 50% is accepted, do this analyze **
    # Analyze if some of these period can be generated by others according to BUFG.
    # For example, if a clock has three choices: 10ns, 20ns, 30ns. If fact BUFGCE_MUX 
    # is not needed. Only a BUFG with an changed enable is needed with a 10ns clock.
    # But, this will lead to duty cycle not being 50%. 
    # The advantage is that, BUFGCE_MUX need to share BUFGCTRL with many other BUF while
    # there are some independent BUFGCE in FPGA.
    

    # Then add temp clocks into domains, remove the original clock for domains.
    # Return new domains and a clock_mux_map.
    
    clk_map = {}
    for domain in list(domains.keys()):
        periods = domains[domain].split()
        num_periods = len(periods)
        if(num_periods>1):
            if(u50_flg):
                sel_clk = []
                for i in range(num_periods):
                    sel_clk.append(domain+"_"+str(i))
                    domains = {**domains, domain+"_"+str(i):periods[i]}
                del domains[domain]
                clk_map[domain] = ["bufgce_mux", sel_clk]
            else:
                return # TODO
                                

    for domain in list(domains.keys()):
        domains[domain] = float(domains[domain])

    return clk_map, domains
    
def bypass_cal(domains):
    # This function is to find clocks with the same period.
    
    clk_map = {}

    lst_domains = list(domains.keys())
    src_clk = lst_domains[0]
    src_clk_val = domains[src_clk]

    for domain in lst_domains[1:]:
        if(domains[domain]==domains[src_clk]):
            clk_map[domain] = ["bypass", src_clk]
            del domains[domain]
    del domains[src_clk]
    
    if(len(domains)==0):
        domains = {src_clk:src_clk_val, **domains}
        return clk_map, domains

    clk_map_child, domains = bypass_cal(domains)
    clk_map.update(clk_map_child)
    domains = {src_clk:src_clk_val, **domains}
    
    return clk_map, domains
   
def pll_mmcm_cal(domains):
    # this function is to calculate the number of PLL and MMCM needed
    # A PLL can generate 2 clock domains and A MMCM can generate 7 clock domains
    # PLL cost less power than MMCM.
    # TODO
    # However, it need to balance the number. 1 PLL cost 0.05W and 1 MMCM cost 0.097 W.
    # For more than 2 clocks need to be generated, MMCM is used. Otherwise, PLL is used.

    mmcm_map = mmcm_multi_calc_fac(domains)
    src_clk = list(mmcm_map.keys())[0]
    num_mmcm_unit = len(mmcm_map[src_clk])
    for mmcm_idx in range(num_mmcm_unit):
        mmcm_caled_domain_lst = mmcm_map[src_clk][mmcm_idx][1]
        if len(mmcm_caled_domain_lst)<3:
            pll_recal_period_list = []
            for domain in mmcm_caled_domain_lst:
                pll_recal_period_list.append(domains[domain])
            pll_fac = pll_calc_fac(domains[src_clk], pll_recal_domain_dict)
            if(pll_map!=[]):
                mmcm_map[src_clk][mmcm_idx][0] = "pll"
                mmcm_map[src_clk][mmcm_idx][2] = pll_fac

    return mmcm_map
                
def clk_resource_cal(domains):
    # clk_map is used to generate some BUFs
    # domains is used to generate PLL
    clk_map_mux, domains =  bufgce_mux_cal(domains, 1)
    clk_map_bypass, domains = bypass_cal(domains)
    clk_map_div, domains =  bufgce_div_cal(domains)
    clk_map_mmcm = pll_mmcm_cal(domains)

    return clk_map_mux, clk_map_bypass, clk_map_div, clk_map_mmcm

